# Ch 8 IO库

C++不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO；

这些类型支持对设备（文件或者控制台窗口）IO操作；

还有一些类型允许内存IO，即从`string`读取数据，向`string`写入数据；

IO库定义了读写内置类型值的操作；此外，一些类，如`string`，通常也会定义类似的IO操作，来读写自己的对象；

Ch8 介绍IO库的基本内容；Ch14 介绍如何编写自己的输入输出运算符；Ch17介绍如何控制输出格式以及如何对文件进行随机访问；

- istream
- ostream
- cin
- cout
- cerr
- \>>
- \<<
- getline

## 8.1 IO库

#### IO类型间的关系

本节剩下的部分所介绍的标准库流特性都可以无差别地用于普通流、文件流和string流，以及char或宽字符流版本；

### 8.1.1 IO对象无拷贝或赋值

我们不能拷贝或对IO对象赋值；

因此也不能将形参或返回类型设置为流类型；

进行IO操作的函数通常以应用方式传递和返回值；

读写一个IO对象会改变其状态，因此传递和返回的引用不能加const；

### 8.1.2 条件状态

IO类定义了一些函数和标志。可以帮助我们访问和操纵流的条件状态（condition state）；

#### 查询流的状态

IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能；这个类型应该作为一个位集合来使用，IO库定义了4个iostate类型的constexpr值来表示特定的位模式；

#### 管理条件状态

流对象的rdstate成员返回一个iostate值，对应流的当前状态；

### 8.1.3 管理输出缓冲

每个输出流都管理一个缓冲区，用于保存程序读写的数据；

导致缓冲刷新的原因有很多：

- 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行；
- 缓冲区满时，需要刷新缓冲；
- 可以使用操纵符如endl来显式刷新缓冲区；
- 在每个输出操作之后，可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的类容都是立即刷新的；
- 一个输出流可能被关联到另一个流。这种情况下，当读写被关联时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新；

#### 刷新输出缓冲区

#### unitbuf操纵符

#### 关联输入和输出流

## 8.2 文件输入输出

### 8.2.1 使用文件流对象

#### 用fstream代替iostream&

#### 成员函数open和close

#### 自动构造和析构

当一个fstream对象被销毁时，close会自动被调用；

### 8.2.2 文件模式

#### 以out模式打开文件会丢弃已有数据

#### 每次调用open时都会确定文件模式

## 8.3 string流

### 8.3.1 使用istringstream

### 8.3.2 使用ostringstream

