# Ch 9 顺序容器

## 9.1 顺序容器概述

所有的顺序容器都提供了快速顺序访问元素的能力，但是这些容器在一下方面会有不同性能的折中：

- 向容器添加或从容器中删除元素的代价；
- 非顺序访问容器中元素的代价；

表9.1: 顺序容器类型

| 容器类型     | 描述                                                       |
| ------------ | :--------------------------------------------------------- |
| vector       | 可变大小数组。支持快速随机访问，在尾部插入删除很快。       |
| deque        | 双向队列。支持快速随机访问，在头尾插入删除都很快。         |
| list         | 双向链表。只支持双向顺序访问，任何位置都可以快速插入删除。 |
| forward_list | 单向链表。只支持单向顺序访问，任何位置都可以快速插入删除。 |
| array        | 固定大小数组。支持快速随机访问。不能添加或者删除元素。     |
| string       | 专门用于保存字符串的容器，与vector相似。                   |

现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

通常使用vector是最好的选择。

如果不确定应该使用哪种容器，那么可以在持续中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector和list都很方便。

## 9.2 容器库概览

容器均定义为模板类；

#### 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。特别的是，可以定义一个容器，其元素的类型是另一个容器。例如：

```cpp
vector<vector<string>> lines;
```

### 9.2.1 迭代器

#### 迭代器范围

迭代器范围的概念是标准库的基础；

对构成范围的迭代器的要求：

如果满足如下条件，那么两个迭代器`begin`和`end`构成一个迭代器范围：

- 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置；
- 我们可以通过反复递增`begin`来到达`end`。换句话说，`end`不在`begin`之前；

#### 使用左闭合范围蕴含的编程假定

### 9.2.2 容器类型成员

### 9.2.3 `begin`和`end`成员

例子：

```cc
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin(); //list<string>::iterator
auto it2 = a.cbegin(); //list<string>::const_iterator
auto it3 = a.rbegin(); //list<string>::reverse_iterator
auto it4 = a.crbegin(); //list<string>::const_reverse_iterator
```

当不需要访问时，应该使用`cbegin`和`cend`；

### 9.3.4 容器定义和初始化

#### 将一个容器初始化为另一个容器的拷贝

Note：当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同；

#### 列表初始化

#### 与顺序容器大小相关的构造函数

Note：只有顺序容器的构造函数才接受大小参数，关联容器并不支持；

#### 标准库`array`具有固定的大小

```cc
array<int, 42> a;
array<string, 10> b;
```

可以对array进行拷贝或者对象复制操作；

### 9.2.5 赋值和swap

标准库`array`类型允许赋值。赋值号左右两边的运算对象必须有相同的类型；

由于右边运算对象的大小可能与左边运算对象的大小不同，因此`array`类型不支持`assign`，也不允许用花括号包围的值列表进行赋值；

`assign`操作不适合于关联容器和`array`；

赋值相关运算会导致指向左边容器的内部的迭代器、引用和指针失效。而`swap`操作符将容器内容交换不会导致指向容器的迭代器、引用和指针失效；

#### 使用`assign`（仅顺序容器）

赋值语句要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝至左边运算对象中；

顺序容器（`array`除外）还定义了一个名为`assign`的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。`assign`操作用参数所指定的元素（的拷贝）；

例如：

```cpp
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; //错误：容器类型不匹配
names.assign(old.style.cbegin(), oldstyle.cend()); //正确，可以将const char* 转换成string
```

Note：由于其就元素被替换，因此传递给`assign`的迭代器不能指向调用`assign`的容器；

`assign`的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素；

```cpp
list<string> slist1(1);
slist1.assign(10, "Hiya!");
```

#### 使用swap

swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换：

```cc
vector<string> svec1(10);
vector<string> svec2(24);
swap(svec1, svec2);
```

Note：除了array之外，swap不对任何元素进行拷贝、删除或者插入操作，因此可以保证在常数时间内完成；

与其他容器不同，swap两个array会真正交换它们的元素。

### 9.2.6 容器大小操作

### 9.2.7 关系运算符

每个容器类型都支持相等运算符；

除了无序关联容器外的所有容器都支持关系运算符；

#### 容器的关系运算符使用元素的关系运算符完成比较

Note：只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器；

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

#### 使用push_back

容器元素是拷贝；

#### 使用push_front

#### 在容器中的特定位置添加元素

#### 插入范围元素

#### 使用insert的返回值

#### 使用emplace操作

Note：emplace函数在容器中直接构造函数。传递给emplace函数的参数必须与元素类型的构造函数相匹配；

### 9.3.2 访问元素

#### 访问成员函数返回的是引用

#### 下表操作和安全的随机访问

### 9.3.3 删除元素

### 9.3.4 特殊的forward_list操作

### 9.3.5 改变容器大小

### 9.3.6 容器操作可能使得迭代器失效

## 9.4 vector对象是如何增长的

#### 管理容量的成员函数

## 9.5 额外的string操作

### 9.5.1 构造函数的其他方法

#### substr操作

### 9.5.2 改变string的其他方法

#### append和replace函数

#### 改变string的多重重载函数

### 9.5.3 string搜索操作

### 9.5.4 compare函数

### 9.5.5 数值转换

## 9.6 容器适配器

除了顺序容器之外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。

适配器是标准库中的一个通用概念；

容器、迭代器和函数都有适配器；

本质上，一个适配器是一种机制，能使得某种事物的行为看起来像另外一种事物一样；

一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型；

#### 定义一个适配器

每个适配器都定义两个构造函数：**默认构造函数创建一个空对象**，接受一个**容器的构造函数**拷贝该容器来初始化适配器；

例如：可以用deque来初始化一个新的stack；

```cpp
deque<int> deq;
stack<int> stk(deq); //从deq拷贝元素到stk
```

默认情况下，stack和queue都是基于deque实现的；

priority_queue是在vector之上实现的；

我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型；

```cc
// 在vector上实现的空栈
stack<string, vector<string>> str_stk;
// str_stk2在vector上实现，初始化时保存svec的拷贝
stack<string, vector<string>> str_stk2(svec);
```

#### 栈适配器

#### 队列适配器

