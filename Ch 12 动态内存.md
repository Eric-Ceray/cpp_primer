# Ch 12 动态内存

除了自动和static对象外，C++还支持动态分配内存。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式当显式地被释放时，这些对象才会销毁；

为了安全使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放的时候，指向它的智能指针可以确保自动地释放它。

静态内存用来保存局部static对象、类static数据成员、以及定义在任何函数之外的变量；

栈内存用来保存定义在函数内的非static对象；

分配在静态或栈内存中的对象由编译器自动创建和销毁；

对于栈对象，仅在其定义的程序块运行的时候存在；

static对象在使用前分配，程序结束时销毁；

程序用堆（heap）来存储动态分配的对象；

动态对象的生命期由程序控制；

## 12.1 动态内存与智能指针

- new
- delete
- shared_ptr
- unique_ptr
- weak_ptr

### 12.1.1 shared_ptr类

智能指针是模版；

默认初始化的智能指针中保存着一份空指针；

如果在一个条件判断中使用智能指针，效果就是检测它是否为空；

#### make_shared函数

```cc
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shard<string>(10, '9');
shared_ptr<int> p5 = make_shared<int>();
auto p6 = make_shared<vector<string>>();
```

#### shared_ptr的拷贝和赋值

当进行拷贝或者赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象；

```cc
auto p=make_shared<int>(42);
auto q(p);
```

每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。

例如，当用一个shared_ptr初始化另一个shared_ptr，或者将它作为参数传递给一个函数，以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或者是shared_ptr被销毁时，计数器就会递减。

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。

#### shared_ptr自动销毁所管理的对象

#### shared_ptr还会自动释放相关联的内存

Note: 如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素；

#### 使用了动态生存期的资源的类

Note：使用动态内存的一个常见原因是允许多个对象共享相同的状态；

#### 定义StrBlob类

```cc
class StrBlob
{
public:
    typedef std::vector<std::string>::size_type size_type;
    StrBlob();
    StrBlob(std::initializer_list<std::string> il);
    size_type size() const {return data->size();}
    bool empty() const {return data->empty();}
    void push_back(const std::string& t) {data->push_back(t);}
    void pop_back();
    std::string& front();
    std::string& back();
private:
    std::shared_ptr<std::vector<std::string>> data;
    // 如果data[i]不合法，抛出一个异常
    void check(size_type i, const std::string& msg) const;
};
```

#### StrBlob构造函数

```cc
StrBlob::StrBlob(): data(make_shared<vector<string>>()) {}
StrBlob::StrBlob(initializer_list<string> il): data(make_shared<vector<string>>(il)) {}
```

#### 元素访问成员函数

```cc
void StrBlob::check(size_type i, const string& msg) const
{
    if(i >= data->size()) throw out_of_range(msg);
}
```

```cc
string& StrBlob::front()
{
    check(0, "front on empty StrBlob");
    return data->front();
}
string& StrBlob::back()
{
    check(0, "back on empty StrBlob");
    return data->back();
}
void StrBlob::pop_back()
{
    check(0, "pop_back on empty StrBlob");
    data->pop_back();
}
```

#### StrBlob的拷贝、赋值和销毁

StrBlob使用默认版本的拷贝、赋值和销毁成员函数来对此类型的对象进行这些操作。默认情况下，这些操作拷贝、赋值和销毁类的数据成员。

### 12.1.2 直接内存管理

自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的让任何默认定义；

使用智能指针的程序更容易编写和调试；

#### 使用new动态分配和初始化对象

```cc
int* pi = new int;
```

默认情况下，动态分配的对象是摩恩初始化的。即对于内置类型或者组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化：

```cc
string* ps = new string; //初始化为空
int* pi = new int; //pi指向一个未初始化的int
```

```cc
int* pi = new int(1024);
string* ps = new string(10, '9');
vector<int>* pv = new vector<int> {0,1,2,3,4,5,6,7,8,9};
```

我们也可以对动态分配的对象进行值初始化，只需要在类型名之后跟一堆括号即可；

```cc
string* ps1 = new string; //默认初始化为空string
string* ps = new string(); //值初始化为空string
int* pi1 = new int; //默认初始化； *pi1的值未定义
int* pi2 = new int(); //值初始化为0； *pi2为0
```

```cc
auto p1 = new auto(obj); // 正确
auto p2 = new auto{a, b, c}； //错误
```

#### 动态分配的const对象

```cc
//分配并初始化一个const int
const int* pci = new const int(1024);
//分配并默认初始化一个const的空string
const string* pcs = new const string;
```

#### 内存耗尽

```cc
//如果分配失败，new返回一个空指针
int* p1 = new int; //如果分配失败，new抛出std::bad_alloc
int* p2 = new (nothrow) int; //如果分配失败，new返回一个空指针
```

#### 释放动态内存

```cc
delete p;
```

#### 指针值和delete

释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的；

编译器不能分辨一个指针指向的是静态还是动态分配的对象；

编译器不能分辨一个指针所指向的内存是否已经被释放了；



虽然一个const对象的值不能被改变，但是它本身是可以销毁的；

```cc
const int* pci = new const int(1024);
delete pci; //正确
```

#### 动态对象的生存期直到被释放时为止

由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放；

Warning: 由内置指针管理的动态内存在被显式释放之前一直都会存在；

坚持只使用智能指针；

#### delete之后重置指针值，这只是提供了有限的保护

当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但是在很多机器上指针任然保存着（已经释放了的）动态内存的地址。即空悬指针。

### 12.1.3 shared_ptr和new结合使用

如果我们不初始化一个智能指针，它就会被初始化为一个空指针；

我们可以用new返回的指针来初始化智能指针：

```cc
shared_ptr<double> p1;
shared_ptr<double> p2(new int(42)); //正确
```

接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针。必须使用直接初始化形式来初始化一个智能指针：

```cc
shared_ptr<int> p1 = new int(1024); //错误
shared_ptr<int> p2(new int(1024)); //正确
```

默认情况下，一个用来初始化智能指针的普通函数指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象；

#### 不要混合使用普通指针和智能指针

使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁；

#### 也不要使用get初始化另一个智能指针或为智能指针赋值

Warning: get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能智能指针赋值；

#### 其他shared_ptr操作

```cc
shared_ptr<int> p;
p = new int(1024); //错误
p.reset(new int(1024)); //正确，p指向一个新对象
```

与赋值类似，reset会更新引用计数；

reset成员经常与unique一起使用；

```cc
if(!p.unique()) p.reset(new string(*p));
*p += newVal;
```

#### 12.1.4 智能指针和异常

#### 智能指针和哑类

包括所有标准库在内的很多C++类都定义了析构函数，负责清理对象使用的资源。但是不是所有的类都是这样良好定义的。特别是那些为C和C++两种语言设计的类，通常都要求用户显式地释放所使用地任何资源；

例如，假定我们正在使用一个C和C++都是用的网络库，使用这个库的代码可能是这样的：

```cc
struct destination; //表示我们正在连接什么
struct connection; //使用连接所需的信息
connection connect(destination*); //打开连接
void disconnect(connection); //关闭给定的连接
void f(destination& d /*其他参数*/)
{
    //获得一个连接；记住使用完后要关闭它
    connection c = connect(&d);
    //使用连接
    //我们在f退出之前忘记调用disconnect，就无法关闭c了
}
```

可以使用sharerd_ptr来保证connection被正常关闭；

#### 使用我们自己的释放操作

```cc
void end_connection(connection* p) {disconnect(*p);}
void f(destination& d /*其他参数*/)
{
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    //使用连接
    //f退出时，即使是异常退出，connection也会被正常关闭
}
```

智能指针陷阱：

- 不使用相同的内置指针初始化（或者reset）多个智能指针；
- 不delete get()返回的指针；
- 不使用get()初始化或者reset另一个智能指针；
- 如果你使用智能指针管理的资源不是new分配的内存，请记住传递给它一个删除器；

### 12.1.5 unique_ptr

一个unique_ptr==拥有==它所指向的对象；

某个时刻只能由一个unique_ptr指向一个给定的对象；

当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。类似shared_ptr，初始化unique_ptr必须采用直接初始化的形式；

```cc
unique_ptr<double> p1;
unique_ptr<int> p2(new int(42));
```

unique_ptr不支持拷贝和赋值；

可以通过调用release和reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique；

```cc
//将所有权从p1转移给p2, p1置空
unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2 = p1.release();

//将所有权从p3转移给p2，p3置空，p2原来指向的对象被释放
unique_ptr<string> p3(new string("Trex"));
p2.reset(p3.release());
```

```cc
p2.release(); //错误
auto p = p2.release(); //正确
```

#### 传递unique_ptr参数和返回unique_ptr

不能拷贝unque_ptr的规则有一个例外：我们可以拷贝或者赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr：

```cc
unique_ptr<int> clone(int p) {return unique_ptr<int>(new int(p));}
```

还可以返回一个局部对象的拷贝：

```cc
unique_ptr<int> clone(int p) {unique_ptr<int> ret(new int(p)); return ret;}
```

#### 向unique_ptr传递删除器

我们必须在尖括号中`unique_ptr`指向的类型之后提供删除器类型：

```cc
unique_ptr<objT, delT> p(new objT, fcn);
```

例如，使用unique重写连接程序：

```cc
void f(destination& d /*其他参数*/)
{
    connection c = connect(&d);//打开连接
    //当p被销毁时，连接关闭
    unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection);
}
```

### 12.1.6 weak_ptr

weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象；

当我们创建一个weak_ptr的时候，需要用一个shared_ptr来初始化它：

```cc
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); //wp弱共享p；p的引用计数不变
```

由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock；

```cc
if(shared_ptr<int> np = wp.lock())
{
    //如果np不为空则条件成立
    //在if中，np与p共享对象
}
```

#### 核查指针类

```cc
class StrBlobPtr
{
public:
    StrBlobPtr(): cur(0) {}
    StrBlobPtr(StrBlob& a, size_t=0): wptr(a.data), currr(sz) {}
    string& deref() const;
    StrBlobPtr& incr(); //前缀递增
private:
    shared_ptr<vector<string>> check(size_t, const string&) const;
    weak_ptr<vector<string>> wptr;
    size_t curr;
};
```

```cc
shared_ptr<vector<string>>
StrBlobPtr::check(size_t i, const string& msg) const
{
    auto ret = wptr.lock(); // vector还存在吗？
    if(!ret) throw runtime_error("unbound StrBlobPtr");
    if(i >= ret->size()) throw out_of_range(msg);
    return ret;
}
```

#### 指针操作

```cc
string& StrBlobPtr::deref() const
{
    auto p = check(curr, "dereference past end");
    return (*p)[curr];
}
```

```cc
StrBlobPtr& StrBlobPtr::incr()
{
    check(curr, "Increment pastend of StrBlobPtr");
    ++curr;
    return *this;
}
```

为了访问data成员，我们的指针类必须声明为StrBlob的friend；

```cc
//对于StrBlob中的友元声明来说，此前置声明是必要的
class StrBlobPtr;
class StrBlob
{
    friend class StrBlobPtr;
    StrBlobPtr begin() {return StrBlobPtr(*this);}
    StrBlobPtr end() {auto rert = StrBlobPtr(*this, data->size()); return ret;}
};
```

## 12.2 动态数组

## 12.3 使用标准库：文本查询程序



